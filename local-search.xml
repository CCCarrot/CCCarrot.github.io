<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SecureNN</title>
    <link href="/2022/04/22/SecureNN/"/>
    <url>/2022/04/22/SecureNN/</url>
    
    <content type="html"><![CDATA[<p>《SecureNN: 3-Party Secure Computation for Neural NetworkTraining》-2019</p><h2 id="摘要">摘要</h2><p>在神经网络算法中包含着线性运算（如矩阵乘法、卷积运算...）以及非线性运算（ReLU、Maxpool、梯度下降...），在之前的解决方案（如SecureML等）中，通常使用算术电路来计算线性运算，使用布尔电路计算非线性运算，但是这样将会面临两种电路之间的转换以及混淆电路严重的通信开销问题。</p><p>本文提出了一种在三方辅助计算下使用的全算术电路来进行隐私保护机器学习的方案，解决了上述两个问题。</p><ul><li>Scalability：首个可以用于卷积神经网络上训练模型的隐私保护机器学习协议。</li><li>Performance：在安全预测任务中，效率优于（SecureML、MiniONN、Chameleon,、Gazelle）6×~113×（在复杂的网络中提升更多）。在安全训练任务中，分别比2-P、3-P的SecureML快79×、3×。</li><li>Security：之前的协议仅提供了半诚实的安全性保证，本文是第一个考虑到在复杂算法（如神经网络的训练和预测）任务中恶意敌手的存在的协议。</li></ul><h2 id="模型">模型</h2><p>本文将问题如下建模：M个数据的持有者希望通过N台服务器来对各自持有的数据使用深度学习的方法联合训练模型。首先，M方将其持有的数据以秘密分享的方式共享给N台服务器，然后这些服务器共同运行一个交互式的协议，在联合数据上训练神经网络，生成所需的模型。安全要求是，任何一个参与方（包括数据持有者及服务器）都不能了解任何其他方的私有数据信息。这被称为N-server模型。</p><p>本文主要考虑N=3（P0、P1、P2）的情况，M是任意的。其中，P0、P1提供输入、获取输出，P2仅提供一定的随机性及进行一些辅助计算。例如：<img src="/img/SecureNN2.png" alt="SecureNN模型" /></p><p>M个医院，持有患者的私密数据，将其秘密分享给P0、P1，然后P0、P1、P2三方执行协议，安全训练出模型，再由患者使用。</p><h2 id="技术概览">技术概览</h2><p>本文主要使用了三个环：<spanclass="math inline">\(Z_{L}、Z_{L-1}、Z_{p}\)</span>，其中，<spanclass="math inline">\(L=2^l\)</span>，p是个小素数，在本文中为67。<spanclass="math inline">\(Z_{L}、Z_{L-1}\)</span>用于对某一输入x的秘密分享，<spanclass="math inline">\(Z_{p}\)</span>用于对x中某一个比特的秘密分享，如图：<img src="/img/SecureNN3.png" alt="三个环的使用" /></p><p>论文主要设计了5个支持协议和5个核心协议，这些协议的关系如图： <imgsrc="/img/SecureNN1.png" alt="协议结构" /></p><h2 id="方案设计">方案设计</h2><h3 id="matrix-multiplication">Matrix Multiplication</h3><p>安全矩阵乘法协议，基本思想与Beaver三元组没有区别。由P2生成乘法三元组，并将其共享给P0、P1。<img src="/img/SecureNN-1.png" alt="Matrix Multiplication" /></p><h3 id="select-share">Select Share</h3><p>共享选择协议的基本要求是使用一个选择比特<spanclass="math inline">\(\alpha\)</span>来获取两个秘密分享份额x、y中的一个，当<spanclass="math inline">\(\alpha=0\)</span>时选择x，反之选择y。输出可以表示为<spanclass="math inline">\((1-\alpha)x+\alpha y=x+\alpha(y-x)\)</span>。 <imgsrc="/img/SecureNN-2.png" alt="Select Share" /></p><h3 id="private-compare">Private Compare</h3><p>本协议需要实现使用算术电路计算非线性运算，那么首先要考虑的就是ReLU函数的实现。ReLU函数的实现关键在于判断x的正负，也就是MSB(x)。通常在求MSB(x)时要做比特提取，这就要用到布尔电路，所以需要将问题进行转化。考虑到在奇数环中有MSB(a)=LSB(2a)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在奇数环中，n为环的阶，MSB(a)=1→a&gt;n/2→n&gt;2a-n&gt;0→2a-n为奇数→LSB(2a-n)=1，有2a-n=2amod n，所以LSB(2a)=1。同理，当MSB(a)=0时，有LSB(2a)=0。">[1]</span></a></sup>，所以此时问题就变成了如何使用算术电路求输入的最低有效位。</p><p>P0、P1本地计算y=2a，有<spanclass="math inline">\(MSB(a)=LSB(y)=y[0]\)</span>，设定<spanclass="math inline">\(r=x+y\;mod\;L-1\)</span>，这样原问题就转化为<spanclass="math inline">\(y[0]=x[0]\bigoplus r[0]\opluswarp(x,y,n)\)</span>，其中<spanclass="math inline">\(warp(x,y,n)=1,iff\;x+y=&gt;n,else\;0\)</span>。<img src="/img/SecureNN-3.png" alt="Private Compare" />要比较x和r哪个大，就是从最高有效位开始往右一个比特一个比特的比较是否相同，找到第一个不同的比特位，然后那个比特为1的就更大。考虑算法的分支结构：</p><ol type="1"><li><span class="math inline">\(\beta=0\)</span>,则<spanclass="math inline">\(\beta{}&#39;=(x&gt;r)\)</span></li></ol><p>此时，算法使用<span class="math inline">\(\omega_{i}\)</span>来表示第i位是否相同（<spanclass="math inline">\(Reconst^{p}(&lt;\omega _{i}&gt;_{0}^{p},&lt;\omega_{i}&gt;_{1}^{p})=\omega _{i}=x[i]\bigoplus r[i]\)</span>），使用<spanclass="math inline">\(c_{i}\)</span>来记录前i位比特是否相同，若x、r第i个比特不同且x[i]=1，则<spanclass="math inline">\(c_{i}=0\)</span>；若x、r第i个比特不同且x[i]=0，则<spanclass="math inline">\(c_{i}=2\)</span>，且后续所有<spanclass="math inline">\(c_{i}=&gt;1\)</span>。最后若存在i使得<spanclass="math inline">\(c_{i}=0\)</span>，则x&gt;r成立。</p><ol start="2" type="1"><li><span class="math inline">\(\beta=1\)</span>,则<spanclass="math inline">\(\beta{}&#39;=(x&lt;=r)=(x&lt;r+1)\)</span><ul><li><span class="math inline">\(r!=2^l-1\)</span>。此时与<spanclass="math inline">\(\beta=0\)</span>的情况类似，仅是变成x与r+1的大小比较。</li><li><spanclass="math inline">\(r=2^l-1\)</span>。此时x&lt;=r恒成立，只需任选一<spanclass="math inline">\(c_{i}\)</span>置为0即可。</li></ul></li></ol><h3 id="share-convert">Share Convert</h3><p>由于PrivateCompare协议只能在奇数环上进行，而输入并不是仅在奇数环上，所以需要一个<spanclass="math inline">\(Z_{L}\rightarrowZ_{L-1}\)</span>的转化协议，功能要求为<spanclass="math inline">\(Reconst^{L-1}(&lt;y&gt;_{0}^{L-1},&lt;y&gt;_{1}^{L-1})=Reconst^{L}(&lt;a&gt;_{0}^{L},&lt;a&gt;_{1}^{L})=a\)</span>。</p><p>这个问题分两种情况考虑：</p><ol type="1"><li><p><spanclass="math inline">\(a_{0}^{L}+a_{1}^{L}&lt;L\)</span>。此时<spanclass="math inline">\(a\;mod\;L=a\;mod\;L-1\)</span>。</p></li><li><p><spanclass="math inline">\(a_{0}^{L}+a_{1}^{L}=&gt;L\)</span>。此时<spanclass="math inline">\(a\;mod\;L=a-1\;mod\;L-1\)</span>。</p></li></ol><p>综上，令<span class="math inline">\(\theta=(a&gt;L)=warp(&lt;a&gt;_{0}^{L},&lt;a&gt;_{1}^{L},L)\)</span>，则可以将问题总结为<spanclass="math inline">\(a\;mod\;L-1=a-(L-1)-\theta\)</span>。此时解决问题的关键就在于求<spanclass="math inline">\(\theta\)</span>。 <img src="/img/SecureNN-4.png"alt="Share Convert" /></p><ol type="1"><li><p><spanclass="math inline">\(r=&lt;r&gt;_{0}^{L}+&lt;r&gt;_{1}^{L}-\alphaL\)</span></p></li><li><p><spanclass="math inline">\(&lt;\tilde{a}&gt;_{j}^{L}=&lt;a&gt;_{j}^{L}+&lt;r&gt;_{j}^{L}-\beta_{j}L\)</span>（Step2）</p></li><li><p><spanclass="math inline">\(x=&lt;\tilde{a}&gt;_{0}^{L}+&lt;\tilde{a}&gt;_{1}^{L}-\deltaL\)</span>（Step4）</p></li><li><p><span class="math inline">\(x=a+r-(1-\eta)L\)</span>（Step5~9）</p></li><li><p><spanclass="math inline">\(a=&lt;a&gt;_{0}^{L}+&lt;a&gt;_{1}^{L}-\thetaL\)</span></p></li></ol><p>最后<span class="math inline">\(1-2-3+4+5\)</span>可得到<spanclass="math inline">\(\theta =\beta _{0}+\beta _{1}-\alpha +\sigma +\eta-1\)</span>（Step10）。</p><h3 id="compute-msb">Compute MSB</h3><p>前边的算法已经把计算MSB所需要的算子实现，所以此时再做MSB(x)就会简单很多。在奇数环中，有<spanclass="math inline">\(MSB(a)=LSB(y)=y[0]=r[0]\bigoplus x[0]\bigopluswrap(y,x,L-1)\)</span>，其中<spanclass="math inline">\(y=2a\)</span>，<spanclass="math inline">\(wrap(y,x,L-1)\Leftrightarrow(x&gt;r)\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="若((x&gt;r))成立，由于<spanclass="math inline">(r=x+y)，所以<spanclass="math inline">(x+y)必然超模，所以<spanclass="math inline">(warp(y,x,L-1)=1)。 "&gt;[2]</span></a></sup>。</p><p>令<span class="math inline">\(\sigma =r[0]\bigoplusx[0]\)</span>，<span class="math inline">\(\gamma=warp(y,x,L-1)=(x&gt;r)\)</span>，得<span class="math inline">\(MSB(a)=\sigma \bigoplus \gamma\)</span>。 <img src="/img/SecureNN-5.png"alt="Compute MSB" /></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>在奇数环中，n为环的阶，MSB(a)=1→a&gt;n/2→n&gt;2a-n&gt;0→2a-n为奇数→LSB(2a-n)=1，有2a-n=2amod n，所以LSB(2a)=1。同理，当MSB(a)=0时，有LSB(2a)=0。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>若<spanclass="math inline">((x&gt;r))</span>成立，由于<spanclass="math inline">(r=x+y)</span>，所以<spanclass="math inline">(x+y)</span>必然超模，所以<spanclass="math inline">(warp(y,x,L-1)=1)</span>。<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>MPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPC</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
